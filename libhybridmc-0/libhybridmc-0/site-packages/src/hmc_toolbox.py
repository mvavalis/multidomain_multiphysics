# compatibility with previous versions
# from fenics import *
from dolfin import *

def make_coord_list(coords):
    l= []
    for i in coords:
        for j in i:
            l.append(j)
    return l

def get_boundary_coords(bc):
    V = bc.function_space()
    d = bc.get_boundary_values().keys()
    coords = V.mesh().coordinates()[d]
    coords = make_coord_list(coords)
    return coords, d

def get_bc_function(bc):
    tmp = bc.value().compute_vertex_values(bc.function_space().mesh())
    bc_val = Function(bc.function_space())
    bc_val.vector()[:] = tmp
    return bc_val

def _errornorm(x,y):
    # set degree_rise according to the difference
    degree_rise = x.ufl_element().degree() - y.ufl_element().degree()
    if degree_rise < 0 or degree_rise > 3:
        print "***  error: invalid degree_rise"
        return True
    error = errornorm(x,y,degree_rise=degree_rise)
    return error

def bc_errornorm(bc,mcbc):
    bc_val = get_bc_function(bc)
    est = get_bc_function(mcbc)
    diff_bc = _errornorm(est,bc_val)
    return diff_bc

def sol_errornorm(x,y):
    return _errornorm(x,y)

def cppcode(form,*args):
    import ufl.algorithms as alg

    # expand_derivatives calls expand_compounds for us

    g = form
    # g = alg.expand_compounds(g)
    g = alg.expand_derivatives(g)
    g = alg.expand_indices(g)
    s = g.__str__()
    for var in args:
        s = s.replace(var.__str__(),
                      var.expression().cppcode)
    return s

def get_module_path(obj):
    import imp
    path = imp.find_module(obj.__module__)
    return path[1]
