from dolfin import *

##############################################
###              Configuration             ###
##############################################

###  FEniCS configuration
#set_log_level(PROGRESS)
#info(parameters,True)

FIXME__use_explicit_interfaces = False

# we define two different meshes, therefore we need a way to interpolate
# between them in order to find the interfaces in each iteration
use_standard_fenics_method = True

if use_standard_fenics_method:
    parameters["allow_extrapolation"] = True
else:
    # override the interpolate() method
    # fenicstools is NOT part of the official FEniCS suite
    # https://github.com/mikaem/fenicstools.git
    from fenicstools import interpolate_nonmatching_mesh as interpolate

##############################################
###                 gnuplot                ###
##############################################
def gnuplotData(title,*_data):
    data = []
    for d in _data:
        if d:
            data.append(d)
    if not data:
        print "no data to plot"
        return

    import Gnuplot
    g = Gnuplot.Gnuplot(persist=1)
    g('set style data lines')
    g('set logscale y')
    g.title(title)
    g.plot(*data)

##############################################
###                  Solve                 ###
##############################################

def stop_criterion(config,subdomain,iteration):
    converged = True
    for iface in subdomain.interfaces.itervalues():
        if not __stop_criterion(config,iface,iteration):
            converged = False
    return converged

def __stop_criterion(config,iface,iteration):
    loginfo = iface['log']
    x = iface['current']
    x_prev = iface['previous']
    x_exact = iface['exact']
###############################################################################

    if x_exact:
        # set degree_rise according to the difference
        degree_rise = x_exact.ufl_element().degree() - x.ufl_element().degree()
        if degree_rise < 0 or degree_rise > 3:
            print "***  error: invalid degree_rise"
            return True
        err_exact = errornorm(x_exact,x,degree_rise=degree_rise)
        n = norm(x_exact)
        if n != 0:
            err_exact /= n

    # set degree_rise according to the difference
    degree_rise = x.ufl_element().degree() - x_prev.ufl_element().degree()
    if degree_rise < 0 or degree_rise > 3:
        print "***  error: invalid degree_rise"
        return True
    err_prev = errornorm(x,x_prev,degree_rise=degree_rise)

    if x_exact:
        msg = "%d\t%f\t%f\n" % (iteration,err_exact,err_prev)
    else:
        msg = "%d\t%f\n" % (iteration,err_prev)
    print msg
    if config.log:
        with open(loginfo.filename, "a") as myfile:
            myfile.write(msg)

    if x_exact:
        loginfo.exact.append([iteration,err_exact])
    if iteration != 1:
        loginfo.prev.append([iteration,err_prev])


    if x_exact:
        if err_exact <= config.tol_exact:
            print "***  matched exact solution  ***"
            return True

    if iteration != 1 and err_prev <= config.tol_prev:
        print "***  no change between iterations %d and %d  ***" %(iteration-1,iteration)
        return True

    if iteration > config.max_iterations:
        print "***  max iterations limit (%d) reached  ***" %(config.max_iterations)
        return True

    return False

def  __create_sessions(subdomains):
    clients = set([ s.client for s in subdomains ])

    for client in clients:
        client.create_session()

def __interpolate_interfaces(subdomains):
    clients = set([ s.client for s in subdomains ])

    for subdomain in subdomains:
        for iface in subdomain.interfaces.itervalues():
            interpolant = interpolate(iface['solution'],subdomain.trial_space())
            iface['interpolant'].vector()[:] = interpolant.vector()
    for client in clients:
        client.send_interpolated_interfaces()

def __solve_iteration(subdomains):
    clients = set([ s.client for s in subdomains ])

    for client in clients:
        client.solve_subdomains()

def __update_interfaces(subdomains):
    clients = set([ s.client for s in subdomains ])

    for subdomain in subdomains:
        for iface in subdomain.interfaces.itervalues():
            iface['previous'].vector()[:] = iface['current'].vector()
            iface['bc'].apply(iface['current'].vector())

def __solve(subdomains,config):
    __create_sessions(subdomains)

    priority = {}
    for subdomain in subdomains:
        if not subdomain.priority in priority:
            priority[subdomain.priority] = []
        priority[subdomain.priority].append(subdomain)
    queues = sorted(priority,reverse=True)

    iteration = 0
    iterate = True
    while iterate:
        iteration += 1
        print "iteration %d" %(iteration)

        for q in queues:
            __interpolate_interfaces(priority[q])
            __solve_iteration(priority[q])
            __update_interfaces(priority[q])

        if config.show_solution_plots:
            for subdomain in subdomains:
                plot(subdomain.solution,title=subdomain.__module__)
                for iface in subdomain.interfaces.itervalues():
                    plot(iface['interpolant'],title='interpolant from ' + iface['log'].filename)
                    # plot(iface['current'],title='current from ' + iface['log'].filename)
                    # plot(iface['previous'],title='previous from ' + iface['log'].filename)

        for subdomain in subdomains:
            if stop_criterion(config,subdomain,iteration):
                iterate = False

    return [ subdomain.solution for subdomain in subdomains ]

def solve(*args, **kwargs):
    subdomains = kwargs.get('subdomains')
    config = kwargs.get('config')

###########    # prepare solver   ##############
    book = {}
    for subdomain in subdomains:
        book[subdomain.__module__] = subdomain

    for subdomain in subdomains:
        for neighbor, interface in subdomain.neighbors().iteritems():
            # 'neighbor' here is just a name (string)
            subdomain.interfaces[neighbor]['solution'] = book[neighbor].solution
            if book[neighbor].exact:
                _exact = Function(subdomain.trial_space())
                tmpBC = DirichletBC(subdomain.trial_space(),book[neighbor].exact,interface)
                tmpBC.apply(_exact.vector())
            else:
                _exact = None
            subdomain.interfaces[neighbor]['exact'] = _exact

##############    # log info   #################
    if config.log:
        for subdomain in subdomains:
            for iface in subdomain.interfaces.itervalues():
                filename = iface['log'].filename
                if iface['exact']:
                    header = "#%s\n#iter\terror(exact)\terror(prev iter)\n" %(filename)
                else:
                    header = "#%s\n#iter\terror(prev iter)\n" %(filename)
                with open(filename, "w") as logfile: logfile.write(header)
################################################

    sol = [ None for j in range(len(subdomains)) ]

    print "***  start iterative solver ..."
    try:
        sol = __solve(subdomains,config)
    except KeyboardInterrupt:
        print "abort solver"

    print "***  end iterative solver ..."

    if config.show_log_plots:
        exact = []
        prev = []
        for subdomain in subdomains:
            for iface in subdomain.interfaces.itervalues():
                if iface['exact']:
                    exact.append(iface['log'].exact)
                prev.append(iface['log'].prev)
        if exact:
            gnuplotData('errornorm(x - exact)',*exact)
        gnuplotData('errornorm(x - x_prev)',*prev)

    return sol
