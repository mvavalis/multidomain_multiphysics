import sys
import os
import uuid

# compatibility with previous versions
# from fenics import *
from dolfin import *
import numpy as np
from hmc_localclient import LocalClient

from spyne import Application, rpc, ServiceBase, Integer, Double, Array, String, Boolean, ByteArray

from spyne.protocol.soap import Soap11
from spyne.server.wsgi import WsgiApplication

import _hybridmc as core

class cd:
    """Context manager for changing the current working directory"""
    def __init__(self, newPath):
        self.newPath = newPath

    def __enter__(self):
        self.savedPath = os.getcwd()
        os.chdir(self.newPath)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.savedPath)

# global
LocalClientOf = {}

class MDMPService(ServiceBase):
    """
    1. convert the input Python lists to numpy arrays
    2. call the core method
    3. return output as Python list
    """

    @rpc(Array(Double),Integer,Array(Double),Integer,String,String,Integer,Double,Integer,Boolean,_returns=Array(Double))
    def montecarlo(ctx, dims, dim, coords, nof_nodes,f,q,walks,btol,threads,OpenCL):
        D = np.array(dims, dtype=np.float_)
        node_coord = np.array(coords, dtype=np.float_)
        if OpenCL and not core.opencl:
            print "****    WARNING    **** : Module %s compiled without OpenCL supprt. Recompile with -DOPENCL_SUPPORT" %(__name__)
            print "****    WARNING    **** : Running multithread CPU version"
            OpenCL = False
        if not OpenCL:
            f = Expression(f)
            q = Expression(q)
        value = core.montecarlo(D,dim,node_coord,nof_nodes,f,q,walks,btol,threads)
        return value

    @rpc(Array(String),Array(String),_returns=String)
    def create_session(ctx,module_names,module_contents):
        session = str(uuid.uuid4())

        client = LocalClient()
        client.create_session()
        LocalClientOf[session] = client

        tmpdir = "./session_%s" %(session)
        tmpdir = os.path.abspath(tmpdir)
        os.mkdir(tmpdir)
        with cd(tmpdir):
            for name, content in zip(module_names,module_contents):
                filename = name + ".py"
                f = open(filename,"w")
                f.write(content)
                f.close()

            sys.path.append(tmpdir)
            map(__import__,module_names)
            sys.path.remove(tmpdir)

            # create subdomains
            for module in module_names:
                m = sys.modules[module]
                problem = m.Problem(client=client)

        return session

    @rpc(String,String,String,Array(Double))
    def interpolate_interface(ctx,session,subdomain_name,neighbor_name,data):
        subdomain = next((s for s in LocalClientOf[session].subdomains if s.__module__ == subdomain_name),None)
        iface = subdomain.interfaces[neighbor_name]

        # interpolate interfaces
        iface['interpolant'].vector()[:] = np.array(data,dtype=np.float_)

        # update interfaces
        iface['previous'].vector()[:] = iface['current'].vector()
        iface['bc'].apply(iface['current'].vector())

    @rpc(String,_returns=Array(Array(Double)))
    def solve(ctx,session):
        LocalClientOf[session].solve_subdomains()

        # return solutions
        solutions = []
        for s in LocalClientOf[session].subdomains:
            c = s.solution.vector()[:]
            solutions.append(c)

        return solutions

def run(address="127.0.0.1",port=8888):
    import logging

    from wsgiref.simple_server import make_server

    application = Application([MDMPService], 'spyne.examples.hello.soap',
                              in_protocol=Soap11(validator='lxml'),
                              out_protocol=Soap11()
    )

    wsgi_application = WsgiApplication(application)

    logging.basicConfig(level=logging.DEBUG)
    logging.getLogger('spyne.protocol.xml').setLevel(logging.DEBUG)

    logging.info("listening to %s:%d" %(address,port))
    logging.info("wsdl is at: http://%s:%d/?wsdl" %(address,port))

    server = make_server(address, port, wsgi_application)
    server.serve_forever()
