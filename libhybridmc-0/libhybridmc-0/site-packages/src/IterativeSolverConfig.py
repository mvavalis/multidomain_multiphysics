##############################################
###        API for the solver              ###
##############################################

# compatibility with previous versions
# from fenics import *
from dolfin import *

from hmc_localclient import LocalClient
from hmc_remoteclient import RemoteClient

class LogInfo():
    def __init__(self,label):
        self.filename = label + ".log"
        self.exact = []
        self.prev = []

class ConfigCommon():
    def __init__(self,*args,**kwargs):
        if 'dim' not in kwargs:
            print "Missing dimensions parameter, assume 2 (2D problem)."
            exit(-1)
        self.dim = kwargs.get('dim',2)

        if 'UID' in kwargs:
            self.UID = kwargs.get('UID')
        else:
            import uuid
            self.UID = uuid.uuid4()

        self.max_iterations = kwargs.get('max_iter',512)
        self.tol_prev = kwargs.get('tol_prev',10e-7)
        self.tol_exact = kwargs.get('tol_exact',10e-5)

        self.priority_domains = kwargs.get('priority_domains',False)

        self.log = kwargs.get('log',True)
        self.show_solution_plots = kwargs.get('show_solution_plots',True)
        self.show_log_plots = kwargs.get('show_log_plots',True)

class Config2D(ConfigCommon):
    def __init__(self,*args,**kwargs):
        kwargs['dim'] = 2
        ConfigCommon.__init__(self,*args,**kwargs)

class Config3D(ConfigCommon):
    def __init__(self,*args,**kwargs):
        kwargs['dim'] = 3
        ConfigCommon.__init__(self,*args,**kwargs)

class ConfigCommonProblem():
    # override this function to initialize custom problem
    def init(self,*args,**kwargs):
        print "Override init() method"
        exit(-1)

    def neighbors(self):
        print "Override neighbors() method"
        exit(-1)

    def boundaries(self):
        print "Override boundary() method"
        exit(-1)

    def solve_problem(self):
        print "Override solve_problem() method or use either a LocalClient or a RemoteClient"
        exit(-1)

    def __init__(self,*args,**kwargs):
        self.init(args,kwargs)

        priority = self.priority if hasattr(self,'priority') else 0
        self.priority = kwargs.get('priority',priority)

        exact = self.exact if hasattr(self,'exact') else None
        self.exact = kwargs.get('exact',exact)

        #######################################################################

        # check if we have all the nesseccary attributes
        error = False
        for key in ('V', 'a', 'L'):
            if not hasattr(self,key):
                print "'%s' attribute not set" %(key)
                error = True
        if error:
            exit(-1)

        self.interfaces = {}
        for neighbor, interface in self.neighbors().iteritems():
            # 'neighbor' here is just a name (string)
            filename = "domain__" + self.__module__ + "__iface__" + neighbor
            d = {}
            d['log'] = LogInfo(filename)
            d['current'] = Function(self.V)
            d['previous'] = Function(self.V)
            d['interpolant'] = Function(self.V)
            d['bc'] = DirichletBC(self.V,d['interpolant'],interface)
            self.interfaces[neighbor] = d

        self.bcs = self.boundaries() + [ i['bc'] for i in self.interfaces.itervalues() ]

        #######################################################################

        self.client = kwargs.get('client')

        if not isinstance(self.client,LocalClient) and not isinstance(self.client,RemoteClient):
            print "Error: expected [  LocalClient | RemoteClient  ] object, got '%s'" %(type(self.client))
            exit(-1)

        self.client.register(self)

        #info(LinearVariationalSolver.default_parameters(), True)
        default_solver_params = {"linear_solver": "gmres"}
        self.solver_params = kwargs.get('solver_params',default_solver_params)
        self.solution = Function(self.V)

################################################

    def trial_space(self):
        return self.V
