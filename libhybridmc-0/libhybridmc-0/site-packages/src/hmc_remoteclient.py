# compatibility with previous versions
# from fenics import *
from dolfin import *

import hmc_toolbox as tools
import numpy as np
import inspect

from suds.client import Client

class RemoteClient(Client):
    def __init__(self,*args,**kwargs):
        self.is_local = False
        self.subdomains = []
        # super(Client,self).__init__(*args,**kwargs)
        Client.__init__(self,*args,**kwargs)

    # def main_dso(self,*args,**kwargs):
    #     value = self.service.main_dso(*args)
    #     return value

    """
    1. send input parameters as Python lists
    2. call the remote method
    3. convert the response from Python list to numpy array
    """

    def montecarlo(self,V,interface,**kwargs):
        import _hybridmc as core

        dims = kwargs.get('Omega')
        bc = DirichletBC(V,1.0,interface)
        coords, keys = tools.get_boundary_coords(bc)
        dim = len(dims)
        nof_nodes = len(coords)/dim

        D = self.factory.create('doubleArray')
        D.double.extend(dims)
        node_coord = self.factory.create('doubleArray')
        node_coord.double.extend(coords)

        f = kwargs.get('f')
        q = kwargs.get('q')
        walks = kwargs.get('walks',5000)
        btol = kwargs.get('btol',1e-13)
        threads = kwargs.get('threads',6)

        OpenCL = kwargs.get('OpenCL',False)
        wrap_value = self.service.montecarlo(D,dim,node_coord,nof_nodes,f,q,
                                             walks,btol,threads,OpenCL)
        value = np.array(wrap_value.double,dtype=np.float_)

        est = Function(V)
        est.vector()[keys] = value
        mcbc = DirichletBC(V,est,interface)
        return mcbc, est

    def register(self,subdomain):
        self.subdomains.append(subdomain)

    def create_session(self,**kwargs):
        _module_names = []
        _module_contents = []
        for s in self.subdomains:
            name = s.__module__
            content = inspect.getsource(inspect.getmodule(s))
            _module_names.append(name)
            _module_contents.append(content)
        module_names = self.factory.create('stringArray')
        module_contents = self.factory.create('stringArray')
        module_names.string.extend(_module_names)
        module_contents.string.extend(_module_contents)

        wrap_contents = self.service.create_session(module_names,module_contents)
        self.session = str(wrap_contents)

    def send_interpolated_interfaces(self,**kwargs):
        for subdomain in self.subdomains:
            for neighbor, interface in subdomain.interfaces.iteritems():
                data = self.factory.create('doubleArray')
                data.double.extend(interface['interpolant'].vector())
                self.service.interpolate_interface(self.session,subdomain.__module__,neighbor,data)

    def solve_subdomains(self,**kwargs):
        wrap_contents = self.service.solve(self.session)
        contents = wrap_contents.doubleArray
        for subdomain, wrap_c in zip(self.subdomains,contents):
            subdomain.solution.vector()[:] = np.array(wrap_c.double,dtype=np.float_)
