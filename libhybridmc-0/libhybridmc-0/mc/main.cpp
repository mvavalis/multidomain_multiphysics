/**
 * More input params:
 * -Should process_solution(int) in LaplaceSolve.run() be called at the end (to get norms and stuff)?
 *  If yes a valid test_u() function in Problem.h is needed, else we don't care about test_u().
 */

#include <memory>
#include <iostream>
#include <vector>
#include <utility>
#include <string.h>
#include <errno.h>
using namespace std;
#include "dd.h"
#include "Pdd.h"
#include "main.h"
#include <dolfin/function/Expression.h>

#ifdef OPENCL_SUPPORT
const bool opencl = true;

//this header is generated by the build system
#include "kernel_paths.h"

#else
const bool opencl = false;
#endif

#ifdef OPENCL_SUPPORT
//MonteCarlo entry point
std::vector<double> montecarlo(double *D, int dim, double* node_coord, int nof_nodes,
                               const std::string &f, const std::string &q,
                               const int walks, const double btol, const int threads, const int mpi_workers)
{
    std::vector<double> est;

    if (dim == 2) {
        struct pdd_prm<2> pp;
        pp.max_nof_threads = threads;  //not used in OpenCL mode
        pp.D[0] = D[0];
        pp.D[1] = D[1];
        pp.nof_walks = walks;
        pp.btol = btol;
        pp.impl = IMPL_CL;
        pp.mpi_workers = mpi_workers;
        pp.cppcode_f = f;
        pp.cppcode_q = q;
        pp.clkernel = MC_KERNEL_2D;
        Pdd<2> pdd(pp);
        est = pdd.pdd(nof_nodes,node_coord);
    }
    else {
        struct pdd_prm<3> pp;
        pp.max_nof_threads = threads;  //not used in OpenCL mode
        pp.D[0] = D[0];
        pp.D[1] = D[1];
        pp.D[2] = D[2];
        pp.nof_walks = walks;
        pp.btol = btol;
        pp.impl = IMPL_CL;
        pp.mpi_workers = mpi_workers;
        pp.cppcode_f = f;
        pp.cppcode_q = q;
        pp.clkernel = MC_KERNEL_3D;
        Pdd<3> pdd(pp);
        est = pdd.pdd(nof_nodes,node_coord);
    }

    return est;
}
#endif

// multithread cpu and MPI entry point
std::vector<double> montecarlo(double *D, int dim, double* node_coord, int nof_nodes,
                               std::shared_ptr<dolfin::Expression> f, std::shared_ptr<dolfin::Expression> q,
                               const int walks, const double btol, const int threads, const int mpi_workers)
{
    std::vector<double> est;

    if (dim == 2) {
        struct pdd_prm<2> pp;
        pp.max_nof_threads = threads;
        pp.D[0] = D[0];
        pp.D[1] = D[1];
        pp.nof_walks = walks;
        pp.btol = btol;
        pp.impl = (mpi_workers) ? IMPL_MPI : IMPL_THREADS;
        pp.mpi_workers = mpi_workers;
        Pdd<2> pdd(pp,f,q);
        est = pdd.pdd(nof_nodes,node_coord);
    }
    else {
        struct pdd_prm<3> pp;
        pp.max_nof_threads = threads;
        pp.D[0] = D[0];
        pp.D[1] = D[1];
        pp.D[2] = D[2];
        pp.nof_walks = walks;
        pp.btol = btol;
        pp.impl = (mpi_workers) ? IMPL_MPI : IMPL_THREADS;
        pp.mpi_workers = mpi_workers;
        Pdd<3> pdd(pp,f,q);
        est = pdd.pdd(nof_nodes,node_coord);
    }

    return est;
}
